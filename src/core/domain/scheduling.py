"""Domain models and helpers for telescope scheduling."""

from __future__ import annotations

from collections.abc import Mapping, Sequence
from dataclasses import dataclass, field
from datetime import datetime
from math import acos, cos, radians, sin


@dataclass(frozen=True)
class Observation:
    """Immutable representation of an observation candidate."""

    target_id: str
    ra_deg: float  # Right ascension in degrees [0, 360)
    dec_deg: float  # Declination in degrees [-90, 90]
    priority: float  # Arbitrary score (>=0)
    duration_hours: float
    constraints: Mapping[str, float] = field(default_factory=dict)

    def __post_init__(self) -> None:
        if not 0.0 <= self.ra_deg < 360.0:
            raise ValueError("ra_deg must be within [0, 360)")
        if not -90.0 <= self.dec_deg <= 90.0:
            raise ValueError("dec_deg must be within [-90, 90]")
        if self.priority < 0:
            raise ValueError("priority must be non-negative")
        if self.duration_hours <= 0:
            raise ValueError("duration_hours must be positive")


@dataclass(frozen=True)
class Schedule:
    """A concrete schedule generated by the core algorithms."""

    observations: tuple[Observation, ...]
    start_time: datetime
    end_time: datetime
    efficiency: float

    def __post_init__(self) -> None:
        if not 0.0 <= self.efficiency <= 1.0:
            raise ValueError("efficiency must be within [0, 1]")
        if self.end_time < self.start_time:
            raise ValueError("end_time must be >= start_time")


def normalize_priority(priority: float, min_val: float, max_val: float) -> float:
    """Normalize a priority value within [min_val, max_val] into [0, 1]."""

    if min_val >= max_val:
        raise ValueError("min_val must be strictly less than max_val")
    clamped = min(max(priority, min_val), max_val)
    return (clamped - min_val) / (max_val - min_val)


def calculate_airmass(
    ra_deg: float, dec_deg: float, lst_hours: float, latitude_deg: float
) -> float:
    """
    Compute airmass using the simple secant(z) approximation.

    Raises:
        ValueError: If the object is below the horizon.
    """

    hour_angle_deg = (lst_hours * 15.0) - ra_deg
    hour_angle_rad = radians(hour_angle_deg)
    latitude_rad = radians(latitude_deg)
    dec_rad = radians(dec_deg)

    # Altitude via spherical astronomy formula
    sin_alt = (sin(latitude_rad) * sin(dec_rad)) + (
        cos(latitude_rad) * cos(dec_rad) * cos(hour_angle_rad)
    )
    if sin_alt <= 0:
        raise ValueError("Target is below the horizon")

    zenith_angle = acos(sin_alt)
    cos_z = cos(zenith_angle)
    if cos_z <= 0:
        raise ValueError("cos(zenith) <= 0; target unreachable")

    return 1.0 / cos_z


AIRMASS_SAFETY_MARGIN = 0.05


def is_observable(
    observation: Observation,
    lst_hours: float,
    latitude_deg: float,
    max_airmass: float = 2.0,
) -> bool:
    """Determine if an observation satisfies the maximum airmass constraint."""

    if max_airmass <= 1.0:
        raise ValueError("max_airmass must be greater than 1.0")

    effective_limit = max_airmass - AIRMASS_SAFETY_MARGIN
    if effective_limit <= 1.0:
        return False

    try:
        airmass = calculate_airmass(
            ra_deg=observation.ra_deg,
            dec_deg=observation.dec_deg,
            lst_hours=lst_hours,
            latitude_deg=latitude_deg,
        )
    except ValueError:
        return False

    return airmass <= effective_limit


def total_priority_weight(observations: Sequence[Observation]) -> float:
    """Aggregate helper for optimization routines."""

    return sum(obs.priority * obs.duration_hours for obs in observations)
